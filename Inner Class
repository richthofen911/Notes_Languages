::概述
  为什么要使用内部类？在《Think in java》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承
  一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。
  在程序设计中有时候会存在一些使用接口很难解决的问题，这个时候可以利用内部类提供的、可以继承多个具体的或者抽象
  的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加
  完整。
  其实使用内部类最大的优点就在于它能够非常好的解决多重继承的问题，但是如果不需要解决多重继承问题，那么自然可以
  使用其他的编码方式，但是使用内部类还能够带来如下特性（摘自《Think in java》）：
      1、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。
      2、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。
      3、创建内部类对象的时刻并不依赖于外围类对象的创建。
      4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。
      5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。
      
::Java中内部类主要分为
  1. 成员内部类
      最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有 成员属性和方法, 外围类要访问
      内部类的成员属性和方法则需要通过内部类实例来访问。
        在成员内部类中要注意两点:
          1)：成员内部类中不能存在任何static的变量和方法；
          2)：成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。
            例子
              public class OuterClass {
                  private String str;
                  
                  public void outerDisplay(){
                      System.out.println("outerClass...");
                  }
                  
                  public class InnerClass{
                      public void innerDisplay(){
                          str = "chenssy...";
                          System.out.println(str);
                          outerDisplay();
                      }
                  }
                  
                  /*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */
                  public InnerClass getInnerClass(){
                      return new InnerClass();
                  }
                  
                  public static void main(String[] args) {
                      OuterClass outer = new OuterClass();
                      OuterClass.InnerClass inner = outer.getInnerClass();
                      inner.innerDisplay();
                  }
              }

  2. 局部内部类
      它是嵌套在方法和作用于内的，这个类的使用主要是用来解决比较复杂的问题，想创建一个类来辅助解决方案，但又
      不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生
      了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。
        例1: 把类定义在方法里
          public class Parcel5 {
              public Destionation destionation(String str){
                  class PDestionation implements Destionation{ //把类定义在方法里
                      private String label;
                      private PDestionation(String whereTo){
                          label = whereTo;
                      }
                      public String readLabel(){
                          return label;
                      }
                  }
                  return new PDestionation(str);
              }
              
              public static void main(String[] args) {
                  Parcel5 parcel5 = new Parcel5();
                  Destionation d = parcel5.destionation("chenssy");
              }
          }
        例2：把类定义在作用域里
          public class Parcel6 {
            private void internalTracking(boolean b){
                if(b){
                    class TrackingSlip{  //类定义在作用域里
                        private String id;
                        TrackingSlip(String s) {
                            id = s;
                        }
                        String getSlip(){
                            return id;
                        }
                    }
                    TrackingSlip ts = new TrackingSlip("chenssy");
                    String string = ts.getSlip();
                }
            }
            
            public void track(){
                internalTracking(true);
            }
            
            public static void main(String[] args) {
                Parcel6 parcel6 = new Parcel6();
                parcel6.track();
            }
        }
      
  3. 匿名内部类
      经常使用这种方式来绑定事件listener
        
  4. 静态内部类      
      使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类
      之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它
      的外围内，但是静态内部类却没有。没有这个引用就意味着：
        1、 它的创建是不需要依赖于外围类的。
        2、 它不能使用任何外围类的非static成员变量和方法。
