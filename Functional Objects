::if a class doesn’thave a body, you don’t need to specify empty curly braces (though you could, and if you wanted to)
  class Rational(n: Int, d: Int)
  
::Immutable object trade-offs
  Immutable objects offer several advantages over mutable objects:
      1. immutable objects are often easier to reason about(reason about是推导的意思) than mutable ones, because 
         they do not have complex state spaces that change over time
      2. you can pass immutable objects around quite freely, whereas you may need to make defensive copies
         of mutable objects before passing them to other code 
      3. there is no way for two threads concurrently accessing an immutable to corrupt its state once it has been 
         properly constructed, because no thread can change the state of an immutable  
      4. immutable objects make safe hash table keys. If a mutable object is mutated after it is placed into a
         HashSet , for example, that object may not be found the next time you look into the HashSet.
         
  and one potential disadvantage:
         they sometimes require that a large object graph(in computer science, an object graph is a view of an object
         system at a particular point in time. Whereas a normal data model such as a UML Class diagram details the 
         relationships between classes, the object graph relates their instances. Object diagrams are subsets of the 
         overall object graph.) be copied where otherwise an update could be done in place.
         In some cases this can be awkward to express and might also cause a performance bottleneck. As a result, 
         it is not uncommon for libraries to provide mutable alternatives to immutable classes. For example, class 
         StringBuilder is a mutable alternative to the immutable String . We’ll give you more information on 
         designing mutable objects in Scala in Chapter 18.

::override
    class Rational(n: Int, d: Int) {
      override def toString = n +"/"+ d
    }
    
::Checking preconditions
    One of the benefits of object-oriented programming is that it allows you to encapsulate data inside objects so
    that you can ensure the data is valid throughout its lifetime. In the case of an immutable object such as 
    Rational ,this means that you should ensure the data is valid when the object is constructed. Given that a zero denominator is an invalid state for a Rational
    number, you should not let a Rational be constructed if a zero is passed in the d parameter.
    The best way to approach this problem is to define as a precondition of the primary constructor that d must be 
    non-zero. A precondition is a constraint on values passed into a method or constructor, a requirement which
    callers must fulfill. One way to do that is to use require， like this:
      class Rational(n: Int, d: Int) {
        require(d != 0)
        override def toString = n +"/"+ d
      }
      
::Adding fiels      
