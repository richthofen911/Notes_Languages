::if a class doesn’thave a body, you don’t need to specify empty curly braces (though you could, and if you wanted to)
  class Rational(n: Int, d: Int)
  
::Immutable object trade-offs
  Immutable objects offer several advantages over mutable objects:
      1. immutable objects are often easier to reason about(reason about是推导的意思) than mutable ones, because 
         they do not have complex state spaces that change over time
      2. you can pass immutable objects around quite freely, whereas you may need to make defensive copies
         of mutable objects before passing them to other code 
      3. there is no way for two threads concurrently accessing an immutable to corrupt its state once it has been 
         properly constructed, because no thread can change the state of an immutable  
      4. immutable objects make safe hash table keys. If a mutable object is mutated after it is placed into a
         HashSet , for example, that object may not be found the next time you look into the HashSet.
         
  and one potential disadvantage:
         they sometimes require that a large object graph(in computer science, an object graph is a view of an object
         system at a particular point in time. Whereas a normal data model such as a UML Class diagram details the 
         relationships between classes, the object graph relates their instances. Object diagrams are subsets of the 
         overall object graph.) be copied where otherwise an update could be done in place.
         In some cases this can be awkward to express and might also cause a performance bottleneck. As a result, 
         it is not uncommon for libraries to provide mutable alternatives to immutable classes. For example, class 
         StringBuilder is a mutable alternative to the immutable String . We’ll give you more information on 
         designing mutable objects in Scala in Chapter 18.

::override
    class Rational(n: Int, d: Int) {
      override def toString = n +"/"+ d
    }
    
::Checking preconditions
    One of the benefits of object-oriented programming is that it allows you to encapsulate data inside objects so
    that you can ensure the data is valid throughout its lifetime. In the case of an immutable object such as 
    Rational ,this means that you should ensure the data is valid when the object is constructed. Given that a zero denominator is an invalid state for a Rational
    number, you should not let a Rational be constructed if a zero is passed in the d parameter.
    The best way to approach this problem is to define as a precondition of the primary constructor that d must be 
    non-zero. A precondition is a constraint on values passed into a method or constructor, a requirement which
    callers must fulfill. One way to do that is to use require， like this:
      class Rational(n: Int, d: Int) {
        require(d != 0)
        override def toString = n +"/"+ d
      }
      
::Adding fields
  To define a public add method on class Rational that takes another Rational as a parameter. To keep Rational 
  immutable, the add method must not add the passed rational number to itself. Rather, it must create and return a
  new Rational that holds the sum. You might think you could write add this way:
    class Rational(n: Int, d: Int) { // This won’t compile
      require(d != 0)
      override def toString = n +"/"+ d
      def add(that: Rational): Rational =
        new Rational(n * that.d + that.n * d, d * that.d)
    }
    
  However, given this code the compiler will complain: <console>:11: error: value (that)d is not a member of 
  Rational new Rational(n * that.d + that.n * d, d * that.d)  
  
  Although class parameters n and d are in scope in the code of your add method, you can only access their value on
  the object on which add was invoked. Thus, when you say n or d in add ’s implementation, the compiler is happy to
  provide you with the values for these class parameters. But it won’t let you say that.n or that.d , because that 
  does not refer to the Rational object on which add was invoked. To access the numerator and denominator on that ,
  you’ll need to make them into fields, like this:
    class Rational(n: Int, d: Int) {
      require(d != 0)
      val numer: Int = n
      val denom: Int = d
      override def toString = numer +"/"+ denom
      def add(that: Rational): Rational =
        new Rational(
          numer * that.denom + that.numer * denom,
          denom * that.denom
        )
    }
  
::Self reference
  The keyword 'this' refers to the object instance on which the currently executing method was invoked, or if used 
  in a constructor, the object instance being constructed.
    def lessThan(that: Rational) =
      this.numer * that.denom < that.numer * this.denom  //这里的this 可以被left out
  
  特殊用法：
    def max(that: Rational) =
      if (this.lessThan(that)) that else this
  
  Here, the first this is redundant. You could have equally well left it off and written: lessThan(that) . But the 
  second this represents the result of the method in the case where the test returns false; were you to omit it, 
  there would be nothing left to return！

::Auxiliary constructors
  Sometimes you need multiple constructors in a class. In Scala, constructors other than the primary constructor are
  called auxiliary constructors. 
    class Rational(n: Int, d: Int) {
      require(d != 0)
      val numer: Int = n
      val denom: Int = d
      def this(n: Int) = this(n, 1) // auxiliary constructor
      override def toString = numer +"/"+ denom
      def add(that: Rational): Rational =
        new Rational(
          numer * that.denom + that.numer * denom,
          denom * that.denom
        )
    }
  
::Defining operators
  class Rational(n: Int, d: Int) {
    require(d != 0)
    private val g = gcd(n.abs, d.abs)
    val numer = n / g
    val denom = d / g
    def this(n: Int) = this(n, 1)
    def + (that: Rational): Rational =
      new Rational(
        numer * that.denom + that.numer * denom,
        denom * that.denom
      )
    def * (that: Rational): Rational =
      new Rational(numer * that.numer, denom * that.denom)
    override def toString = numer +"/"+ denom
    private def gcd(a: Int, b: Int): Int =
      if (b == 0) a else gcd(b, a % b)
  }

::Method overloading
  def + (that: Rational): Rational =
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
    def + (i: Int): Rational =
      new Rational(numer + i * denom, denom)
  
::Implicit conversions 书p.156
  
  
