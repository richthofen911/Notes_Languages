http://www.open-open.com/bbs/view/1320131360999

在JDK1.5之前，Java中要进行业务并发时，通常需要有程序员独立完成代码实现，当然也有一些开源的框架提供了这些功能，
但是这些依然没有JDK自带的功能使用起来方便。而当针对高质量Java多线程并发程序设计时,为防止死蹦等现象的出现，比如
使用java之前的wait()、notify()和synchronized等，每每需要考虑性能、死锁、公平性、资源管理以及如何避免线程安全性
方面带来的危害等诸多因素，往往会采用一些较为复杂的安全策略，加重了开发负担。在JDK1.5出现之后，Sun的大神
Doug Lea推出了java.util.concurrent工具包, 提供了更实用的并发程序模型以简化并发完成。开发者们借助于此，将有效的
减少竞争条件(race conditions）和死锁线程

重要并发模型概览：
Executor                  ：具体Runnable任务的执行者。
ExecutorService           ：线程池管理者，实现类有多种，这里涉及部分。可把Runnable,Callable提交到池中让其调度
Semaphore                 ：一个计数信号量
ReentrantLock             ：一个可重入的互斥锁定 Lock，功能类似synchronized，但要强大的多。
Future                    ：与Runnable,Callable进行交互的接口，比如一个线程执行结束后取返回的结果等等，
                            还提供了cancel终止线程。
BlockingQueue             ：阻塞队列。
CompletionService         : ExecutorService的扩展，可以获得线程执行结果的
CountDownLatch            ：同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待 
CyclicBarrier             ：同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 
Future                    ：Future 表示异步计算的结果。
ScheduledExecutorService  ：一个 ExecutorService，可安排在给定的延迟后运行或定期执行的命令。

详细
Executor/ExecutorService: Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是
                          一个执行线程的工具。真正的线程池接口是ExecutorService。
                          结构图 http://www.blogjava.net/images/blogjava_net/xylz/Windows-Live-Writer/-Java-Concurrency-28--part-1-_1302E/Executor-class_thumb.png
                          Executor的execute方法只是执行一个Runnable的任务，当然了从某种角度上将最后的实现类也是
                          在线程中启动此任务的。根据线程池的执行策略最后这个任务可能在新的线程中执行，或者线程
                          池中的某个线程，甚至是调用者线程中执行（相当于直接运行Runnable的run方法）
                          ExecutorService在Executor的基础上增加了一些方法，其中有两个核心的方法：
                            Future<?> submit(Runnable task)
                            <T> Future<T> submit(Callable<T> task)
                          这两个方法都是向线程池中提交任务，它们的区别在于Runnable在执行完毕后没有结果，
                          Callable执行完毕后有一个结果。这在多个线程中传递状态和结果是非常有用的。另外他们的
                          相同点在于都返回一个Future对象。Future对象可以阻塞线程直到运行完毕（获取结果，如果
                          有的话），也可以取消任务执行，当然也能够检测任务是否被取消或者是否执行完毕。在没有
                          Future之前我们检测一个线程是否执行完毕通常使用Thread.join()或者用一个死循环加状态
                          位来描述线程执行完毕。现在有了更好的方法能够阻塞线程，检测任务执行完毕甚至取消执行
                          中或者未开始执行的任务  
