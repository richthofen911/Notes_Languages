::HotSpot 架构
  http://www.cnblogs.com/shudonghe/p/3457990.html
  
::应用程序性能的衡量要素
  通常优化一个Java应用时，重点关心的是响应时间或吞吐量。  
    响应时间指的是应用或者系统对一个请求数据的回应。例如：
        桌面UI对鼠标事件的响应速度
        网站返回页面的速度
        数据库查询返回的速度
      对于重点关心响应时间的应用，较长时间的应用暂停时不可接受的。要做到尽可能的提升响应速度，减少响应时间。
    吞吐量重点关心特定时间内应用程序处理工作的最大值。例如，吞吐量可以通过以下形式来衡量：
      给定时间内的完成的事物数量，比如一个小时内完成的批处理程序的个数， 一个小时内完成的数据库查询的次数
      这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应不必考虑  
  
::什么是自动垃圾收集机制？
  自动垃圾收集机制是查看堆内存、区分在使用的对象和未使用的对象、删除未使用的对象的一个过程。对于使用对象或者
  引用对象，指的是你的程序持有一个指向那个对象的引用。对于未使用的对象或者是无引用对象，则不被你程序的任何部分
  持有引用。所以，无引用对象使用的内存是可以被重新回收利用的。
  Java中，内存的回收是由垃圾回收器自动处理的。基本的步骤可以描述如下：
   1. 标记。  通过这一步骤来区分哪块内存在使用，那哪块内存未使用。
      引用对象用蓝色标识，未引用的对象用金色标识。在标记阶段，扫描所有的对象并判断。如果系统中所有的对象都要被
      扫描，那么这一步骤可能非常耗时。
   2. 正常删除。  正常删除移除无引用对象，留下引用对象及指向空闲空间的指针。
      内存分配器持有空闲内存的引用，这些空闲内存都链接到一个List中，当需要的时候可以分配给新的对象。
    2.1 带压缩删除     为了进一步改善性能，除了删除未引用的对象，用户也可以压缩存活的引用对象。把引用对象
        移动到一起，通过这种方法可以使更快速、更方便的分配新的内存。
        

::分代垃圾回收机制
  在早期的JVM上，不得不在所有的对象上进行标记-压缩，这显然是非常低效。随着越来越多的对象被分配，对象列表也
  逐渐增大，这就导致越来越长的垃圾回收时间。然而，根据经验我们分析得到大部分对象的生命周期是非常短暂的。据此
  可以增强JVM的性能。因此，堆被分解为较小的三个部分或者三个代。具体分为：
    年轻代(young generation)、老年代(old generation)、持久代(permanent generation)。
  年轻代：所有创建的新对象都是在年轻代分配堆空间，在这一代变老。当年轻代被填满的时候，这就会导致一个小收集。
          如果对象的死亡率很高，小回收就可以获得优化。年轻代中死亡的对象越多，回收的速度也就越快。幸存对象
          逐渐变老（年纪增大），最终会移动到老年代。  
  老年代：老年代用于存储较长生命周期的对象。典型的说来就是，为年轻代对象设置了阈值，当年轻代逐渐变老，到达
          这个阈值的时候，对象就会被移动到老年代。随着时间的推移，老年代也会被填满，最终导致老年代也要进行
          垃圾回收。这个事件叫做大收集。
          大收集也是全局暂停事件。通常大收集比较慢，因为它涉及到所有的存活对象。所以，对于对相应时间要求高的
          应用，应该将大收集最小化。此外，对于大收集，全局暂停事件的暂停时长会受到用于老年代的垃圾回收器的
          影响。
  持久代：持久代存储了描述应用程序类和方法的元数据，JVM运行应用程序的时候需要这些元数据。持久代由JVM在运行时
          基于应用程序所使用的类产生。此外，Java SE类库的类和方法可能也存储在这里。        
  如果JVM发现有些类不在被其他类所需要，同时其他类需要更多的空间，这时候这些类可能就会被垃圾回收。  
  
::垃圾回收的一般步骤
    1.首先，所有新生成的对象都是放在年轻代的Eden分区的，初始状态下两个Survivor分区都是空的。年轻代的目标
      就是尽可能快速的收集掉那些生命周期短的对象
    2.当Eden区满的的时候，小垃圾收集就会被触发。当Eden分区进行清理的时候，会把引用对象移动到第一个
      Survivor分区，无引用的对象删除。
      
      
    
