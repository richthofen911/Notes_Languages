stack(栈), heap(堆)

stack和heap都是内存的一部分

stack 空间小，速度比较快，用来放对象的引用
heap 比较大，一般所创建的对象本身都放在这里

stack是先进后出的结构，在JVM中功能是内存指令区，用于基本数据类型，指令代码，常量，对象的引用地址。
     栈中数据的生存空间一般在当前scope（也就是{})内
heap是一个可动态申请的内存空间(其记录空闲内存空间的链表由操作系统维护)，在JVM中功能是内存数据区，用于存放
    对象实例。C中的malloc语句所产生的内存空间就在heap
    **特别的：保存对象实例，实际上是保存对象实例的属性值，属性的类型和对象本身的类型标记等，并不保存对象的
    方法（因为方法是指令，保存在stack中）。
    对象实例在heap中分配好以后，需要在stack中保存一个4字节的heap内存地址，用来定位该对象实例在heap中的位置，
    便于找到该对象实例。

java中所有使用new xxx()构造出来的对象都在堆中存储，当垃圾回收器检测到某对象未被引用，则自动销毁该对象。所以
理论上java中对象的生存空间是没有限制的，只要有引用类型指向它，它就可以在任意地方被使用

stack与heap都是java用来在RAM中存放数据的地方，Java自动管理stack和heap，程序员不能直接地设置它们

stack的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是存在栈中的数据大小与生存期必须是确定的，
缺乏灵活性。另外，栈数据可以共享，详见下一条。
heap的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。
但缺点是，由于要在运行时动态分配内存，存取速度较慢。

Java中的数据类型有两种。
  一种是基本类型(primitive types), 共有8种:
      int, short, long, byte, float, double, boolean, char(注意，并没有string的基本类型)。
    这种类型的定义是通过诸如int a = 3;的形式来定义的，称为自动变量。值得注意的是，自动变量存的是字面值，不是
    类的实例，即不是类的引用，这里并没有类的存在。如int a = 3; 这里的a是一个指向int类型的引用，指向3这个字面
    值。这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，字段值
    就消失)，出于追求速度的原因，就存在于栈中
    另外，栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：
              int a = 3;
              int b = 3；
    编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟
    一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有
    3这个字面值，便将b直接指向3的地址。
    这样，就出现了a与b同时均指向3的情况。特别注意的是，这种字面值的引用与类对象的引用不同。
    假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另一个对象引用
    变量也即刻反映出这个变化。
    相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。
    如上例，我们定义完a与b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新
    搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的
    改变不会影响到b的值。
  另一种是包装类数据，如Integer, String, Double等将相应的基本数据类型包装起来的类。这些类数据全部存在于堆中，
    Java用new()语句来显示地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间。
    String是一个特殊的包装类数据。可以用String str = new String("abc");的形式来创建，也可以用
    String str = "abc"；的形式来创建
    
    
http://pterodactyl.iteye.com/blog/345892
http://android.blog.51cto.com/268543/50100    
    
  

